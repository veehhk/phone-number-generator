using PhoneNumberGenerator.Library.Abstract;

namespace PhoneNumberGenerator.Library.Concrete
{
    /// <summary>
    /// Represents a navigation logic for the provided keypad layout and chess coin
    /// </summary>
    /// <param name="keypad"></param>
    /// <param name="chessCoin"></param>
    public class KeyPadNavigator(IKeypad keypad, IChessCoin chessCoin) : IKeyPadNavigator
    {
        private readonly IKeypad keypad = keypad;
        private readonly IChessCoin chessCoin = chessCoin;

        private HashSet<string> results = [];
        private HashSet<char> validStartingDigits = ['2', '3', '4', '5', '6', '7', '8', '9'];

        /// <summary>
        /// Returns the list of phone numbers generated by a coin
        /// </summary>
        /// <param name="circular"></param>
        /// <returns></returns>
        public HashSet<string> GenerateNumbers(bool circular)
        {
            for (int row = 0; row < keypad.GetRowCount(); row++)
            {
                for (int column = 0; column < keypad.GetColumnCount(); column++)
                {
                    char startDigit = keypad.GetKey(row, column);
                    if (validStartingDigits.Contains(startDigit))
                    {
                        GenerateNumbers(row, column, startDigit.ToString(), circular);
                    }
                }
            }

            return this.results;
        }

        /// <summary>
        /// Private overloaded method called by GenerateNumbers(bool circular) and it navigates through the matrix data provided as parameters
        /// </summary>
        /// <param name="row"></param>
        /// <param name="column"></param>
        /// <param name="current"></param>
        /// <param name="circular"></param>
        private void GenerateNumbers(int row, int column, string current, bool circular)
        {
            if (current.Length == 7)
            {
                results.Add(current);
                return;
            }

            foreach (var move in chessCoin.GetMoves())
            {
                for (int step = 1; ; step++)
                {
                    int newRow = row + move.Item1 * step;
                    int newColumn = column + move.Item2 * step;

                    //This circular logic can help the navigator to loop around the matrix instead of navigating within its edges. As of now commented.
                    //if (circular)
                    //{
                    //    // Handle circular movement
                    //    newRow = (newRow + keypad.GetRowCount()) % keypad.GetRowCount();
                    //    newColumn = (newColumn + keypad.GetColumnCount()) % keypad.GetColumnCount();
                    //}

                    if (!keypad.IsValidPosition(newRow, newColumn))
                    {
                        break; // Exit loop if position is invalid
                    }

                    char nextDigit = keypad.GetKey(newRow, newColumn);
                    if (nextDigit == '*' || nextDigit == '#')
                    {
                        break; // Exit loop if next digit is invalid
                    }

                    GenerateNumbers(newRow, newColumn, current + nextDigit, circular);

                    if (chessCoin.IsSingleStep())
                    {
                        break; // Break after one step if the coin moves single step
                    }
                }
            }
        }

        /// <summary>
        /// Returns the total count of phone numbers generated
        /// </summary>
        /// <returns></returns>
        public int GetResultsCount() => this.results.Count();
    }
}
